Great â€” here are three fully separated automation rules, each with its own trigger, scope, and JSON.
This setup is the most stable and recommended approach for Jira Server/Data Center.

These three rules will keep everything perfectly synced:

1ï¸âƒ£ Sub-task â†’ Task
2ï¸âƒ£ Task â†’ Epic
3ï¸âƒ£ Epic â†’ Recalculate remaining + original

Each rule is isolated to avoid recursion and automation loops.

â¸»

âœ… RULE 1 â€” Sync Time From Sub-task â†’ Task

Trigger

Work Logged

Condition (optional but recommended)

Issue Type = Sub-task

Branch: Parent (Task)

Action â†’ Edit Issue â†’ Additional fields

Paste JSON:

{
  "fields": {
    "timetracking": {
      "originalEstimate": "{{issue.timetracking.originalEstimate}}",
      "remainingEstimate": "{{#=}}{{issue.timetracking.originalEstimateSeconds}} - {{issue.timetracking.timeSpentSeconds}}{{/}}",
      "timeSpent": "{{issue.timetracking.timeSpent}}"
    }
  }
}

âœ” What this rule does
	â€¢	Any work logged on a Sub-task immediately updates the Task time tracking.

â¸»

âœ… RULE 2 â€” Roll up totals from Tasks â†’ Epic

Trigger

Issue Updated

With field: Time Spent OR Original Estimate OR Remaining Estimate
(issue type = Task)

Branch: Parent â†’ Epic

Before the branch, add:

Action â†’ Lookup Issues

Use this JQL:

"Epic Link" = {{issue.epic.key}} OR parent = {{issue.epic.key}}

Then inside the Epic branch:

Action â†’ Edit Issue â†’ Additional fields

JSON:

{
  "fields": {
    "timetracking": {
      "originalEstimate": "{{#=}}{{lookupIssues.Sum.timetracking.originalEstimateSeconds}} / 60}}{{/}}m",
      "remainingEstimate": "{{#=}}{{lookupIssues.Sum.timetracking.originalEstimateSeconds}} - {{lookupIssues.Sum.timetracking.timeSpentSeconds}}{{/}}",
      "timeSpent": "{{lookupIssues.Sum.timetracking.timeSpentSeconds}}"
    }
  }
}

âœ” What this rule does
	â€¢	Whenever a Task changes its estimate or logs time
â†’ The Epic instantly recalculates total Original Estimate, Remaining, and Time Spent.

â¸»

âœ… RULE 3 â€” Recalculate Epic if child issues updated indirectly

This rule catches edge cases such as:
	â€¢	Editing a Taskâ€™s estimate without logging time
	â€¢	Removing a worklog
	â€¢	Bulk updates
	â€¢	Manually changing Original Estimate

Trigger

Scheduled (Every 5 minutes)
â€”orâ€”
Issue Updated (Epic only)

Recommended:

Scheduled â†’ Run JQL:
issuetype = Epic

Action â†’ Lookup Issues

JQL:

"Epic Link" = {{issue.key}} OR parent = {{issue.key}}

Action â†’ Edit Issue â†’ Additional fields

Paste JSON:

{
  "fields": {
    "timetracking": {
      "originalEstimate": "{{#=}}{{lookupIssues.Sum.timetracking.originalEstimateSeconds}} / 60}}{{/}}m",
      "remainingEstimate": "{{#=}}{{lookupIssues.Sum.timetracking.originalEstimateSeconds}} - {{lookupIssues.Sum.timetracking.timeSpentSeconds}}{{/}}",
      "timeSpent": "{{lookupIssues.Sum.timetracking.timeSpentSeconds}}"
    }
  }
}

âœ” What this rule does
	â€¢	Keeps Epics 100% in sync even if someone edits fields manually or outside normal workflow.

â¸»

ğŸ‰ Your Setup Is Now Complete

With these three rules:

Action	Sub-task	Task	Epic
Sub-task logs time	âœ” Updates	â€”	â€”
Task updates estimate/time	â€”	âœ” Updates	âœ” Updates
Epic auto-refreshes via rule 3	â€”	â€”	âœ” Always correct

No loops
No double-triggering
No stale values

â¸»

ğŸ‘‰ If you want, I can generate:

âœ… A single downloadable JSON file containing all 3 rules
OR
âœ… Step-by-step screenshots matching your Jira UI

Just tell me which you prefer!
Got it.
You do NOT need to write a JQL for each Epic, even if you have hundreds of Epics.

Automation allows you to write one JQL that dynamically picks the correct Epic every time, no matter which Task or Sub-task triggers the rule.

Below are the correct dynamic JQL patterns depending on which rule youâ€™re building.

â¸»

âœ… 1. For Rule 2 (Task â†’ Epic roll-up)

This runs when a Task is updated and you want to collect ALL Tasks + Sub-tasks inside that Taskâ€™s Epic.

Use this JQL inside Lookup Issues:

"Epic Link" = {{issue.epic.key}} OR parent in (issuesInEpics("key = {{issue.epic.key}}"))

If your Jira doesnâ€™t support issuesInEpics() (some Server/DC versions donâ€™t), use the safe fallback:

"Epic Link" = {{issue.epic.key}} OR parent = {{issue.epic.key}}

âœ” This handles ANY number of Epics automatically

No need to change the rule per Epic.

â¸»

âœ… 2. For Rule 3 (Scheduled Epic refresh)

If you want to loop through every Epic in your project, use this JQL:

issuetype = Epic AND project = YOURPROJECTKEY

This lets the automation visit every Epic one by one.

Inside the rule, for each Epic, you use:

"Epic Link" = {{issue.key}} OR parent in (issuesInEpics("key = {{issue.key}}"))

This Lookup Issues JQL finds all Tasks + Subtasks for the current Epic, no matter how many epics you have.

â¸»

âœ” COMPLETE EXAMPLE

If you schedule the rule every 5 minutes:

Trigger â†’ Scheduled

JQL:

issuetype = Epic

Action â†’ Lookup Issues

JQL:

"Epic Link" = {{issue.key}} OR parent = {{issue.key}}

Action â†’ Edit Issue â†’ Additional Fields:

{
  "fields": {
    "timetracking": {
      "originalEstimate": "{{lookupIssues.Sum.timetracking.originalEstimateSeconds}}s",
      "remainingEstimate": "{{#=}}{{lookupIssues.Sum.timetracking.originalEstimateSeconds}} - {{lookupIssues.Sum.timetracking.timeSpentSeconds}}{{/}}s",
      "timeSpent": "{{lookupIssues.Sum.timetracking.timeSpentSeconds}}s"
    }
  }
}

This works for any number of Epics, any number of Tasks, any number of Sub-tasks.

â¸»

âš¡ Summary

You donâ€™t need a separate JQL per Epic

You only need:

âœ” {{issue.epic.key}}

when rule is triggered by a Task

OR

âœ” {{issue.key}}

when rule is running on an Epic itself.

Jira replaces these smart values with the correct Epic automatically.

â¸»

If you want, I can now provide:

âœ… All 3 rules fully assembled
OR
âœ… Screenshots (AI generated) for each rule with visual steps

Just tell me â€œGive screenshots for all 3 rulesâ€.