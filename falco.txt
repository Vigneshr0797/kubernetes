Perfect ðŸ‘ â€” hereâ€™s a **ready-to-apply full YAML** setup for your on-premises Kubernetes (v1.28.14, RHEL 8, containerd runtime) with **Falco v0.41.3** and **Falco driver-loader v0.41.3** using **eBPF**.

This manifest includes:

* The `falco` namespace
* ConfigMap (rules + config)
* DaemonSet (runs one pod per node, mounting `/etc/falco`)

---

### âœ… **`falco-daemonset-containerd-ebpf.yaml`**

```yaml
---
apiVersion: v1
kind: Namespace
metadata:
  name: falco
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: falco-config
  namespace: falco
data:
  falco.yaml: |
    rules_file:
      - /etc/falco/falco_rules.yaml
    time_format_iso_8601: true
    json_output: true
    json_include_output_property: true
    priority: debug
    outputs:
      - name: stdout
        enabled: true
  falco_rules.yaml: |
    # --- Falco Default Rules for Container Runtime Security ---
    - rule: Terminal shell in container
      desc: Detect shell spawned inside a container
      condition: container.id != host and proc.name in (bash, sh, zsh, ksh)
      output: >
        Shell spawned in container (user=%user.name container=%container.id command=%proc.cmdline)
      priority: WARNING
      tags: [container, shell]

    - rule: Write below binary dir
      desc: Detect any write below /bin or /usr/bin
      condition: evt.type in (open, creat) and evt.dir = < and fd.name startswith /bin
      output: >
        File written below binary dir (file=%fd.name user=%user.name command=%proc.cmdline)
      priority: CRITICAL
      tags: [filesystem, mitre_execution]

    - rule: Privileged container started
      desc: Detect privileged container creation
      condition: container.privileged=true
      output: Privileged container started (container=%container.id image=%container.image.repository)
      priority: WARNING
      tags: [container, privilege]
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: falco
  namespace: falco
  labels:
    app: falco
spec:
  selector:
    matchLabels:
      app: falco
  template:
    metadata:
      labels:
        app: falco
    spec:
      serviceAccountName: falco
      hostPID: true
      hostNetwork: true
      dnsPolicy: ClusterFirstWithHostNet
      tolerations:
        - operator: Exists
      containers:
        - name: falco-driver-loader
          image: falco-driver-loader:0.41.3
          securityContext:
            privileged: true
          resources:
            requests:
              cpu: 50m
              memory: 50Mi
            limits:
              memory: 200Mi
          env:
            - name: FALCO_BPF_PROBE
              value: "/root/.falco/falco-bpf.o"
          volumeMounts:
            - name: modules
              mountPath: /lib/modules
            - name: usr
              mountPath: /usr
            - name: falco-config
              mountPath: /etc/falco
        - name: falco
          image: falco:0.41.3
          securityContext:
            privileged: true
          args:
            - /usr/bin/falco
            - -r
            - /etc/falco/falco_rules.yaml
          resources:
            requests:
              cpu: 100m
              memory: 200Mi
            limits:
              memory: 500Mi
          volumeMounts:
            - name: modules
              mountPath: /lib/modules
              readOnly: true
            - name: usr
              mountPath: /usr
              readOnly: true
            - name: falco-config
              mountPath: /etc/falco
              readOnly: true
      volumes:
        - name: modules
          hostPath:
            path: /lib/modules
        - name: usr
          hostPath:
            path: /usr
        - name: falco-config
          configMap:
            name: falco-config
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: falco
  namespace: falco
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: falco-cluster-role
rules:
  - apiGroups: [""]
    resources: ["pods", "namespaces", "nodes"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["apps"]
    resources: ["deployments", "replicasets", "daemonsets"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: falco-cluster-role-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: falco-cluster-role
subjects:
  - kind: ServiceAccount
    name: falco
    namespace: falco
```

---

### ðŸš€ **Apply the manifest**

```bash
kubectl apply -f falco-daemonset-containerd-ebpf.yaml
```

Check pods:

```bash
kubectl -n falco get pods -o wide
```

---

### ðŸ“œ **Check logs**

```bash
kubectl -n falco logs -f <falco-pod-name> -c falco
```

You should see:

```
Loading rules from file /etc/falco/falco_rules.yaml
Falco initialized with eBPF driver
```

---

### ðŸ§ª **Test**

```bash
kubectl run test-shell --image=busybox -it -- sh
```

Inside:

```bash
sh
```

Then exit and check:

```bash
kubectl -n falco logs -f <falco-pod-name> -c falco | grep "Shell spawned"
```

Youâ€™ll see Falco detect a shell process in a container.

---

Would you like me to modify this YAML to **use your locally available Falco images from your private registry (Harbor)** instead of the public ones? That way, it will run fully offline in your cluster.
